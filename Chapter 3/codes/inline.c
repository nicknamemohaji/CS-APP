/*
GCC의 인라인 어셈블리 사용 예시

문법: __asm__ __volatile__ (어셈블리 명령어, 출력 피연산자, 입력 피연산자, 부수 효과)
- __asm__: 어셈블리 코드임을 나타내는 키워드
- __volatile__: 컴파일러가 최적화를 하지 못하도록 하는 키워드
- 어셈블리 명령어: 어셈블리 코드
(한 줄의 긴 문자열이지만, 가독성을 위해 \n을 사용하여 줄바꿈을 해주는 것이 좋음)
- 출력 피연산자: 어셈블리 코드를 통해 변경되는 값(변수)
- 입력 피연산자: 어셈블리 코드를 통해 입력되는 값(변수)
- 부수 효과: 어셈블리 코드를 통해 변경되는 레지스터 목록

출력과 입력 피연산자는 C 코드의 변수를 사용할 수 있음.
=m: 메모리에 있는 변수
=r: 레지스터에 있는 변수

컴파일 옵션: gcc -Og -S inline.c
- -Og: 디버깅을 위한 최적화 옵션
    (-O0와 비교해 보면, -Og는 최적화를 하기는 하지만, 읽기 쉬운 어셈블리 코드를 생성. -O0는 최적화를 하지 않음)
- -S: 어셈블러만 실행하여 어셈블리 코드를 생성(오브젝트 파일 생성 X)

- -masm=intel을 사용하면 ATT 문법 대신 Intel 문법으로 어셈블리 코드를 생성할 수 있음
*/

#include <stdio.h>

int main(void)
{
    int x, y;
    __asm__ __volatile__(
        "movl $0x0, %%eax;\n"   // 레지스터의 경우 어셈블리에서 `%eax`와 같이 쓰므로, 인라인 어셈블리에서는 `%%eax`와 같이 써야 함
                                // (문자열 포매팅에 의해 %%가 %을 의미하기 때문)
                                // 즉 이 string literal은 "movl $0x0, %eax;\n"와 같음
        "movl $0x0, %%edx;\n"
        "leal 7(%%edx, %%edx, 4), %%edx;\n"
        "movl %%edx, %0;"       // 여기서 %0은 출력 피연산자를 의미. %%가 아니라 %임에 주의
                                // 출력 피연산자는 순서대로 %0, %1, %2, ...로 지정
                                // 여기서는 %0이 x를 의미하므로, x에 edx의 값을 저장하라는 의미
        : "=m" (x)
        :
        : "%eax", "%edx"
    );
    printf("x = %d\n", x);
}