# (C언어로 작성된) 프로그램의 일생주기

프로그램이 처음 작성되어 실행될 수 있기까지는 *컴파일*과정을 거친 후, 다른 프로그램에 의해 실행되어야 한다.

## 1. 소스코드 단계

프로그램은 프로그래머가 작성한 C 언어 소스 코드로 일생주기를 시작한다. 이 단계에서 C로 작성된 소스코드는 디스크에 텍스트 형태로 존재한다.

## 2. 컴파일 단계

[!컴파일 시스템](../images/compile%20system.png)

프로그램이 실행되기 위해서는 고수준의 C언어 소스 코드에서 저수준의 기계어 인스트럭션으로 번역되어야 한다. 이 과정을 컴파일이라고 한다.

> JAVA, Python과 같이 중간 수준의 언어로 번역된 후 인터프리터에서 순차적으로 실행하는 언어도 있다. 이들을 인터프리터 언어라고 한다.
C, Rust 등은 대표적인 컴파일 언어로, 소스 코드에서 해당 실행환경에 맞추어 컴파일되어야 한다.

### 2-1. 전처리기(cpp)

C언어에는 전처리기 명령(Preprocessor Directive)이라는 문법이 존재한다. 전처리기 문법은 헤더파일을 참조(include)하거나 매크로를 선언(definie)하는 등의 작업을 수행한다. 전처리기는 `.c`로 작성된 소스코드를 받아, `.i` 형식을 갖는 새로운 C 소스코드를 생성한다. 

### 2-2. 컴파일러(cc1)

컴파일러는 C언어 소스코드를 Assembly어로 번역한다. 어셈블리어는 기계어 인스트럭션에 대응되는 저수준 언어이다. 어셈블리어에 대해서는 [3장](../../Chapter%203/readme.md)에서 자세히 다룬다. 어셈블러는 `.i` 형식을 갖는 소스코드를 받아, `.s`형식을 갖는 어셈블리어 소스코드로 번역한다. 

### 2-3. 어셈블러(as)

어셈블러는 어셈블리어 소스코드를 기계어 인스트럭션으로 번역한다. `.s` 형식의 어셈블리어 코드를 `.o`형식의 목적 파일로 번역한다. 

이 목적 파일은 바이너리이지만, 실행 가능한 바이너리가 아니다. 이를 *재배치 가능 목적 프로그램*(`relocatable object program`)이라 한다.

### 2-4. 링커(ld)

링커는 목적 파일이 호출하는 다른 목적 파일들을 통합해 하나의 실행 가능한 파일을 만든다. 이때 각 인스트럭션의 주소들이 재지정된다. 최종적으로 *실행 가능 목적파일*(`executable object program`)이 생성된다. 

참고로, 책에서 사용하는 환경은 다음과 같다.
- x86-64 아키텍쳐
- Ubuntu Linux 12.04
- gnu-gcc v4.8


## 3. 메모리 적재

프로그램은 다른 프로그램(쉘, 데스크톱 환경 등)에 의해 실행된다. 

1. 실행 파일을 디스크(보조 저장장치)에서 메모리(주 저장장치)로 로딩
2. 프로세서는 PC 레지스터를 참조해, 레지스가 가리키는 위치(메모리)에서 기계어 인스트럭션을 캐시로 로딩
3. 인스트럭션에 따라 입출력 버스를 통해 입출력 작업 수행
